import './App.css.proxy.js';
/* src/App.svelte generated by Svelte v3.29.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../web_modules/svelte/internal.js";

import Popup from "./Popup.js";
import Status from "./Status.js";
import Grid from "./Grid.js";

function create_default_slot(ctx) {
	let button;
	let button_autofocus_value;
	let button_tabindex_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Play again!";
			button.autofocus = button_autofocus_value = true;
			attr(button, "tabindex", button_tabindex_value = 0);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*reset*/ ctx[9]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let main;
	let popup;
	let t0;
	let status;
	let updating_gridHeight;
	let updating_gridWidth;
	let t1;
	let grid;
	let main_style_value;
	let current;

	popup = new Popup({
			props: {
				title: /*gameStatus*/ ctx[2] === "lost" ? "ðŸ˜µ" : "ðŸŽ‰",
				show: /*showPopup*/ ctx[3],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	function status_gridHeight_binding(value) {
		/*status_gridHeight_binding*/ ctx[13].call(null, value);
	}

	function status_gridWidth_binding(value) {
		/*status_gridWidth_binding*/ ctx[14].call(null, value);
	}

	let status_props = {
		missingCells: /*missingCells*/ ctx[5],
		usedFlags: /*usedFlags*/ ctx[6],
		numberOfBombs: /*numberOfBombs*/ ctx[7],
		height: /*statusHeight*/ ctx[8]
	};

	if (/*gridHeight*/ ctx[0] !== void 0) {
		status_props.gridHeight = /*gridHeight*/ ctx[0];
	}

	if (/*gridWidth*/ ctx[1] !== void 0) {
		status_props.gridWidth = /*gridWidth*/ ctx[1];
	}

	status = new Status({ props: status_props });
	binding_callbacks.push(() => bind(status, "gridHeight", status_gridHeight_binding));
	binding_callbacks.push(() => bind(status, "gridWidth", status_gridWidth_binding));

	grid = new Grid({
			props: {
				height: /*gridHeight*/ ctx[0],
				width: /*gridWidth*/ ctx[1],
				bombs: /*numberOfBombs*/ ctx[7],
				topOffset: /*statusHeight*/ ctx[8],
				reset: /*gridReset*/ ctx[4]
			}
		});

	grid.$on("cells", /*handleReveal*/ ctx[10]);
	grid.$on("flags", /*handleFlag*/ ctx[11]);
	grid.$on("gameOver", /*handleGameOver*/ ctx[12]);

	return {
		c() {
			main = element("main");
			create_component(popup.$$.fragment);
			t0 = space();
			create_component(status.$$.fragment);
			t1 = space();
			create_component(grid.$$.fragment);
			attr(main, "style", main_style_value = `--grid-height: ${/*gridHeight*/ ctx[0]}; --grid-width: ${/*gridWidth*/ ctx[1]}`);
			attr(main, "class", "svelte-1cyhqsa");
		},
		m(target, anchor) {
			insert(target, main, anchor);
			mount_component(popup, main, null);
			append(main, t0);
			mount_component(status, main, null);
			append(main, t1);
			mount_component(grid, main, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const popup_changes = {};
			if (dirty & /*gameStatus*/ 4) popup_changes.title = /*gameStatus*/ ctx[2] === "lost" ? "ðŸ˜µ" : "ðŸŽ‰";
			if (dirty & /*showPopup*/ 8) popup_changes.show = /*showPopup*/ ctx[3];

			if (dirty & /*$$scope*/ 32768) {
				popup_changes.$$scope = { dirty, ctx };
			}

			popup.$set(popup_changes);
			const status_changes = {};
			if (dirty & /*missingCells*/ 32) status_changes.missingCells = /*missingCells*/ ctx[5];
			if (dirty & /*usedFlags*/ 64) status_changes.usedFlags = /*usedFlags*/ ctx[6];
			if (dirty & /*numberOfBombs*/ 128) status_changes.numberOfBombs = /*numberOfBombs*/ ctx[7];

			if (!updating_gridHeight && dirty & /*gridHeight*/ 1) {
				updating_gridHeight = true;
				status_changes.gridHeight = /*gridHeight*/ ctx[0];
				add_flush_callback(() => updating_gridHeight = false);
			}

			if (!updating_gridWidth && dirty & /*gridWidth*/ 2) {
				updating_gridWidth = true;
				status_changes.gridWidth = /*gridWidth*/ ctx[1];
				add_flush_callback(() => updating_gridWidth = false);
			}

			status.$set(status_changes);
			const grid_changes = {};
			if (dirty & /*gridHeight*/ 1) grid_changes.height = /*gridHeight*/ ctx[0];
			if (dirty & /*gridWidth*/ 2) grid_changes.width = /*gridWidth*/ ctx[1];
			if (dirty & /*numberOfBombs*/ 128) grid_changes.bombs = /*numberOfBombs*/ ctx[7];
			if (dirty & /*gridReset*/ 16) grid_changes.reset = /*gridReset*/ ctx[4];
			grid.$set(grid_changes);

			if (!current || dirty & /*gridHeight, gridWidth*/ 3 && main_style_value !== (main_style_value = `--grid-height: ${/*gridHeight*/ ctx[0]}; --grid-width: ${/*gridWidth*/ ctx[1]}`)) {
				attr(main, "style", main_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(popup.$$.fragment, local);
			transition_in(status.$$.fragment, local);
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popup.$$.fragment, local);
			transition_out(status.$$.fragment, local);
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(main);
			destroy_component(popup);
			destroy_component(status);
			destroy_component(grid);
		}
	};
}

const bombRatio = 0.2;

function instance($$self, $$props, $$invalidate) {
	let gridHeight;
	let gridWidth;
	let gameStatus;
	let statusHeight;
	let showPopup;
	let gridReset;
	let missingCells;
	let usedFlags;

	const reset = () => {
		$$invalidate(3, showPopup = false);
		$$invalidate(2, gameStatus = "ongoing");
		$$invalidate(4, gridReset = true);
		$$invalidate(5, missingCells = gridHeight * gridWidth);
		$$invalidate(6, usedFlags = 0);
	};

	reset();

	const handleReveal = ({ detail: { remainingCells } }) => {
		if (gameStatus !== "ongoing") {
			return;
		}

		$$invalidate(5, missingCells = remainingCells);
		$$invalidate(4, gridReset = false);
	};

	const handleFlag = ({ detail: { remainingCells, numberOfFlags } }) => {
		if (gameStatus !== "ongoing") {
			return;
		}

		$$invalidate(6, usedFlags = numberOfFlags);
		$$invalidate(5, missingCells = remainingCells);
		$$invalidate(4, gridReset = false);
	};

	const handleGameOver = () => {
		$$invalidate(2, gameStatus = "lost");
		$$invalidate(3, showPopup = true);
	};

	function status_gridHeight_binding(value) {
		gridHeight = value;
		$$invalidate(0, gridHeight);
	}

	function status_gridWidth_binding(value) {
		gridWidth = value;
		$$invalidate(1, gridWidth);
	}

	let numberOfBombs;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*gridHeight, gridWidth*/ 3) {
			$: $$invalidate(7, numberOfBombs = Math.floor(gridHeight * gridWidth * bombRatio));
		}

		if ($$self.$$.dirty & /*gridHeight, gridWidth*/ 3) {
			$: {
				$$invalidate(5, missingCells = gridHeight * gridWidth);
				$$invalidate(6, usedFlags = 0);
			}
		}

		if ($$self.$$.dirty & /*missingCells*/ 32) {
			$: if (missingCells === 0) {
				$$invalidate(2, gameStatus = "victory");
				$$invalidate(3, showPopup = true);
			}
		}
	};

	return [
		gridHeight,
		gridWidth,
		gameStatus,
		showPopup,
		gridReset,
		missingCells,
		usedFlags,
		numberOfBombs,
		statusHeight,
		reset,
		handleReveal,
		handleFlag,
		handleGameOver,
		status_gridHeight_binding,
		status_gridWidth_binding
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;